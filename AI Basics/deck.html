<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Slide Deck</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
      html, body { height: 100%; background: #000; }
      body { margin: 0; font-family: 'Inter', sans-serif; }
      #stage { position: fixed; inset: 0; display: grid; place-items: center; }
      #frame { width: 1280px; height: 720px; border: 0; background: #000; transform-origin: center center; will-change: transform; }
      .hud { position: fixed; bottom: 12px; left: 12px; right: 12px; display: flex; align-items: center; justify-content: space-between; color: #9CA3AF; font-size: 12px; }
      .btn { background: rgba(255,255,255,0.08); color: #fff; padding: 8px 12px; border-radius: 6px; cursor: pointer; user-select: none; }
      .btn:active { transform: scale(0.98); }
      .dots { display: flex; gap: 6px; align-items: center; }
      .dot { width: 6px; height: 6px; border-radius: 50%; background: #374151; }
      .dot.active { background: #fff; }
      .click-zones { position: fixed; inset: 0; display: grid; grid-template-columns: 1fr 1fr; }
      .click-left, .click-right { height: 100%; }
      .gate-overlay { position: fixed; inset: 0; background: #000000; display: grid; place-items: center; z-index: 100; }
    </style>
  </head>
  <body>
    <div id="stage">
      <iframe id="frame" title="Slides" scrolling="no"></iframe>
    </div>
    <div class="click-zones">
      <div class="click-left"></div>
      <div class="click-right"></div>
    </div>
    <div class="hud">
      <div class="flex items-center gap-2">
        <a href="../index.html" class="btn" id="back" title="Back to dashboard">← Dashboard</a>
        <div class="btn" id="prev">← Prev</div>
        <div class="btn" id="next">Next →</div>
      </div>
      <div id="filename" class="truncate mx-2"></div>
      <div class="flex items-center gap-2">
        <div class="dots" id="dots"></div>
        <div class="btn" id="fsBtn" title="Press F to toggle">Fullscreen</div>
      </div>
    </div>
    <div id="gate" class="gate-overlay" style="display:none">
      <div style="position:absolute; top:24px; left:0; right:0; display:flex; justify-content:center;">
        <img src="../public/Logo1.png?v=1" alt="Logo" style="height:96px" />
      </div>
      <div class="w-full max-w-sm mx-auto bg-black border border-gray-800 rounded-xl p-6 text-white">
        <h2 class="text-xl font-bold mb-4 text-center">Enter Password</h2>
        <input id="pw" type="password" placeholder="Password" class="w-full px-4 py-3 rounded bg-gray-900 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-white" />
        <label class="mt-3 flex items-center gap-2 text-sm text-gray-300"><input id="show" type="checkbox" class="form-checkbox"> Show password</label>
        <button id="go" class="mt-4 w-full py-3 rounded bg-white text-black font-semibold">Unlock</button>
        <p id="err" class="text-red-400 text-sm mt-3 hidden">Incorrect password. Try again.</p>
      </div>
    </div>
    <script>
      // Slides will be populated from slide_state.json
      let slides = [];
      let idx = 0;
      const frame = document.getElementById('frame');
      const prevBtn = document.getElementById('prev');
      const nextBtn = document.getElementById('next');
      const dots = document.getElementById('dots');
      const filename = document.getElementById('filename');

      function renderDots() {
        dots.innerHTML = '';
        slides.forEach((s, i) => {
          const d = document.createElement('div');
          d.className = 'dot' + (i === idx ? ' active' : '');
          d.title = s.title || s.file;
          d.onclick = () => { idx = i; load(); };
          dots.appendChild(d);
        });
      }

      function load() {
        const current = slides[idx];
        if (!current) return;
        const cacheBuster = 'v=' + Date.now();
        const sep = current.file.includes('?') ? '&' : '?';
        frame.src = current.file + sep + cacheBuster;
        filename.textContent = (idx + 1) + '/' + slides.length + ' — ' + (current.title || current.file);
        renderDots();
        window.history.replaceState({}, '', `#${idx}`);
      }

      function next() { idx = (idx + 1) % slides.length; load(); }
      function prev() { idx = (idx - 1 + slides.length) % slides.length; load(); }

      // Fullscreen helpers
      function isFullscreen() {
        return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
      }
      async function enterFullscreen() {
        const el = document.documentElement;
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
        if (el.mozRequestFullScreen) return el.mozRequestFullScreen();
        if (el.msRequestFullscreen) return el.msRequestFullscreen();
      }
      async function exitFullscreen() {
        if (document.exitFullscreen) return document.exitFullscreen();
        if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
        if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
        if (document.msExitFullscreen) return document.msExitFullscreen();
      }
      function updateFsButton() {
        const fs = isFullscreen();
        const btn = document.getElementById('fsBtn');
        if (btn) btn.textContent = fs ? 'Exit Fullscreen' : 'Fullscreen';
      }

      // Keyboard navigation
      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') { e.preventDefault(); next(); }
        if (e.key === 'ArrowLeft' || e.key === 'PageUp' || e.key === 'Backspace') { e.preventDefault(); prev(); }
        if (e.key === 'Home') { idx = 0; load(); }
        if (e.key === 'End') { idx = slides.length - 1; load(); }
        if (e.key.toLowerCase && e.key.toLowerCase() === 'f') {
          e.preventDefault();
          if (isFullscreen()) { exitFullscreen(); } else { enterFullscreen(); }
        }
      });

      // Click/tap navigation
      document.querySelector('.click-left').addEventListener('click', prev);
      document.querySelector('.click-right').addEventListener('click', next);
      prevBtn.addEventListener('click', prev);
      nextBtn.addEventListener('click', next);
      document.getElementById('fsBtn').addEventListener('click', () => {
        if (isFullscreen()) { exitFullscreen(); } else { enterFullscreen(); }
      });
      document.addEventListener('fullscreenchange', updateFsButton);
      document.addEventListener('webkitfullscreenchange', updateFsButton);
      document.addEventListener('mozfullscreenchange', updateFsButton);
      document.addEventListener('MSFullscreenChange', updateFsButton);

      async function init() {
        try {
          const res = await fetch('slide_state.json', { cache: 'no-store' });
          const state = await res.json();
          const outline = Array.isArray(state.outline) ? state.outline : [];
          // Build slide list from outline ids, mapping to corresponding HTML files
          slides = outline.map(item => ({
            file: (item && item.id ? item.id : 'unknown') + '.html',
            title: item && item.title ? item.title : (item && item.id ? item.id : 'unknown')
          }))
          // Filter unknowns and de-duplicate by file
          .filter(s => s.file !== 'unknown.html')
          .filter((s, i, arr) => arr.findIndex(t => t.file === s.file) === i);
          // Fallback if outline empty
          if (slides.length === 0) {
            slides = [
              { file: 'title.html', title: 'Title' }
            ];
          }
        } catch (e) {
          // Minimal fallback on error
          slides = [
            { file: 'title.html', title: 'Title' }
          ];
        }
        const start = parseInt(location.hash.replace('#',''), 10);
        if (!Number.isNaN(start) && start >= 0 && start < slides.length) idx = start;
        load();
        layout();
      }
      function layout() {
        const baseW = 1280;
        const baseH = 720;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const scale = Math.min(vw / baseW, vh / baseH);
        document.getElementById('frame').style.transform = `scale(${scale})`;
      }
      window.addEventListener('resize', layout);
      document.addEventListener('fullscreenchange', layout);
      document.addEventListener('webkitfullscreenchange', layout);
      document.addEventListener('mozfullscreenchange', layout);
      document.addEventListener('MSFullscreenChange', layout);
      init();
    </script>
    <script>
      // Same client-side gate as dashboard (obfuscation only)
      (function() {
        const allowed = ['Berries','berries','BERRIES'];
        const KEY = 'training_gate_session';
        const gate = document.getElementById('gate');
        const err = document.getElementById('err');
        const input = document.getElementById('pw');
        const btn = document.getElementById('go');
        const show = document.getElementById('show');
        function unlocked() { return sessionStorage.getItem(KEY) === '1'; }
        function setUnlocked() { sessionStorage.setItem(KEY, '1'); }
        function showGate() { gate.style.display = 'grid'; setTimeout(() => input && input.focus(), 0); }
        function hideGate() { gate.style.display = 'none'; }
        function attempt() {
          const value = (input && input.value || '').trim();
          if (allowed.includes(value)) { setUnlocked(); hideGate(); }
          else { if (err) err.classList.remove('hidden'); }
        }
        if (!unlocked()) { showGate(); } else { hideGate(); }
        if (btn) btn.addEventListener('click', attempt);
        if (input) input.addEventListener('keydown', (e) => { if (e.key === 'Enter') attempt(); });
        if (show && input) show.addEventListener('change', () => { input.type = show.checked ? 'text' : 'password'; });
      })();
    </script>
  </body>
  </html>



